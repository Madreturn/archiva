package org.apache.maven.archiva.plugins.dev.testgen;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.iterators.EnumerationIterator;
import org.apache.maven.archiva.plugins.dev.functors.MatchingDependencyPredicate;
import org.apache.maven.artifact.InvalidArtifactRTException;
import org.apache.maven.model.Dependency;
import org.apache.maven.model.DistributionManagement;
import org.apache.maven.model.Exclusion;
import org.apache.maven.model.Model;
import org.apache.maven.model.Relocation;
import org.apache.maven.plugin.MojoExecutionException;
import org.codehaus.plexus.util.IOUtil;
import org.codehaus.plexus.util.StringUtils;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

/**
 * MemoryRepositoryCreator 
 *
 * @author <a href="mailto:joakim@erdfelt.com">Joakim Erdfelt</a>
 * @version $Id$
 */
public class MemoryRepositoryCreator
    extends AbstractCreator
{
    private File outputFile;

    private PrintWriter out;

    private int modelsProcessed = 0;

    public void create( String classPrefix )
        throws MojoExecutionException
    {
        getLog().info( "Generating " + classPrefix + "MemoryRepository.java ..." );
        getLog().info( "Please be patient, this can take a few minutes ..." );

        modelsProcessed = 0;

        outputFile = new File( outputDir, classPrefix + "MemoryRepository.java" );
        try
        {
            out = new PrintWriter( outputFile );
        }
        catch ( FileNotFoundException e )
        {
            throw new MojoExecutionException( "Unable to open file " + outputFile.getName() + " for output: "
                + e.getMessage(), e );
        }

        try
        {
            out.println( "package org.apache.maven.archiva.dependency.graph;" );
            out.println( "" );

            writeLicense( out );

            // Imports
            out.println( "import org.apache.maven.archiva.model.ArchivaProjectModel;" );
            out.println( "import org.apache.maven.archiva.model.Dependency;" );
            out.println( "import org.apache.maven.archiva.model.VersionedReference;" );
            out.println( "" );

            String projectKey = toKey( project.getModel() );

            writeJavadoc( classPrefix + "MemoryRepository", projectKey );

            // The class itself.
            out.println( "public class " + classPrefix + "MemoryRepository" );
            out.println( "   extends AbstractMemoryRepository" );
            out.println( "{" );

            writeTest();

            out.println( "}" );
        }
        finally
        {
            out.flush();
            IOUtil.close( out );
        }

    }

    private void writeJavadoc( String classname, String projectKey )
    {
        out.println( "/**" );
        out.println( " * " + classname );
        out.println( " * " );
        out.println( " * MemoryRepository for testing <code>" + projectKey + "</code>" );
        out.println( " *" );
        out.println( " * Generated by <code>archivadev:generate-dependency-tests</code> plugin" );
        out.println( " * @version $Id$" );
        out.println( " */" );
    }

    private void writeTest()
    {
        out.println( "   public void initialize()" );
        out.println( "   {" );
        out.println( "      ArchivaProjectModel model;" );
        out.println( "      Dependency dep;" );
        out.println( "" );

        Set seenModels = new HashSet();

        writeModel( seenModels, project.getModel() );

        getLog().info(
                       "Processing done: Processed " + modelsProcessed + " models (" + seenModels.size()
                           + " were unique)" );

        out.println( "   }" );
    }

    private void writeModel( Set seenModels, Model model )
    {
        String projectKey = toKey( model );

        modelsProcessed++;

        if ( ( modelsProcessed % 100 ) == 0 )
        {
            getLog()
                .info( "Processed " + modelsProcessed + " models (" + seenModels.size() + " unique) ..." );
        }

        Relocation relocation = null;

        if ( seenModels.contains( projectKey ) )
        {
            return;
        }

        seenModels.add( projectKey );

        out.println( "      model = toModel( \"" + projectKey + "\" );" );

        if ( model.getParent() != null )
        {
            String parentKey = toKey( model.getParent() );
            out.println( "      model.setParentProject( toParent( \"" + parentKey + "\" ) );" );
        }

        if ( isNotEmpty( model.getDependencies() ) )
        {
            Iterator it = model.getDependencies().iterator();
            while ( it.hasNext() )
            {
                Dependency dep = applyDepMan( (Dependency) it.next(), model );

                writeAddDependency( "addDependency", dep );
            }
        }

        if ( ( model.getDependencyManagement() != null )
            && isNotEmpty( model.getDependencyManagement().getDependencies() ) )
        {
            Iterator it = model.getDependencyManagement().getDependencies().iterator();
            while ( it.hasNext() )
            {
                Dependency dep = (Dependency) it.next();

                writeAddDependency( "addDependencyManagement", dep );
            }
        }

        if ( isNotEmpty( model.getProperties() ) )
        {
            Iterator it = new EnumerationIterator( model.getProperties().keys() );
            while ( it.hasNext() )
            {
                String key = (String) it.next();
                String value = model.getProperties().getProperty( key );
                out.println( "      model.addProperty( \"" + key + "\", \"" + value + "\" );" );
            }
        }

        if ( model.getDistributionManagement() != null )
        {
            DistributionManagement distMgmt = model.getDistributionManagement();

            if ( distMgmt.getRelocation() != null )
            {
                relocation = distMgmt.getRelocation();

                out.println( "      model.setRelocation( new VersionedReference() );" );
                if ( StringUtils.isNotEmpty( relocation.getGroupId() ) )
                {
                    out.println( "      model.getRelocation().setGroupId( \"" + relocation.getGroupId() + "\" );" );
                }
                if ( StringUtils.isNotEmpty( relocation.getArtifactId() ) )
                {
                    out
                        .println( "      model.getRelocation().setArtifactId( \"" + relocation.getArtifactId()
                            + "\" );" );
                }
                if ( StringUtils.isNotEmpty( relocation.getVersion() ) )
                {
                    out.println( "      model.getRelocation().setVersion( \"" + relocation.getVersion() + "\" );" );
                }
            }
        }

        out.println( "      addModel( model );" );
        out.println( "" );

        if ( model.getParent() != null )
        {
            Model parentModel = getModel( model.getParent() );
            writeModel( seenModels, parentModel );
        }

        if ( relocation != null )
        {
            Model relocatedModel = getModel( model, relocation );
            writeModel( seenModels, relocatedModel );
        }

        writeModelDependencies( seenModels, projectKey, model );
        writeModelDependencyManagement( seenModels, projectKey, model );
    }

    private Model getModel( Model model, Relocation relocation )
    {
        String groupId = relocation.getGroupId();
        String artifactId = relocation.getArtifactId();
        String version = relocation.getVersion();

        // Set empty groupId.
        if ( StringUtils.isEmpty( groupId ) )
        {
            groupId = model.getGroupId();

            if ( StringUtils.isEmpty( groupId ) )
            {
                if ( model.getParent() == null )
                {
                    throw new IllegalStateException( "BAD POM: GroupId for relocation in " + toKey( model )
                        + " cannot be determined, as there is no Parent Pom reference." );
                }

                groupId = model.getParent().getGroupId();
            }
        }

        // Set empty artifactId.
        if ( StringUtils.isEmpty( artifactId ) )
        {
            artifactId = model.getArtifactId();

            if ( StringUtils.isEmpty( artifactId ) )
            {
                if ( model.getParent() == null )
                {
                    throw new IllegalStateException( "BAD POM: ArtifactId for relocation in " + toKey( model )
                        + " cannot be determined, as there is no Parent Pom reference." );
                }

                artifactId = model.getParent().getArtifactId();
            }
        }

        // Set empty version.
        if ( StringUtils.isEmpty( version ) )
        {
            version = model.getVersion();

            if ( StringUtils.isEmpty( version ) )
            {
                if ( model.getParent() == null )
                {
                    throw new IllegalStateException( "BAD POM: version for relocation in " + toKey( model )
                        + " cannot be determined, as there is no Parent Pom reference." );
                }

                version = model.getParent().getVersion();
            }
        }

        return getModel( groupId, artifactId, version, "pom" );
    }

    private void writeAddDependency( String addMethod, Dependency dep )
    {
        boolean useShortForm = true;
        String depKey = toKey( dep );

        useShortForm = isEmpty( dep.getExclusions() ) && !dep.isOptional();

        String scopePart = "";

        if ( isNotBlank( dep.getScope() ) )
        {
            scopePart = ", \"" + dep.getScope() + "\"";
        }

        if ( useShortForm )
        {
            out.println( "      model." + addMethod + "( toDependency( \"" + depKey + "\"" + scopePart + " ) );" );
            return;
        }

        out.println( "      dep = toDependency( \"" + depKey + "\"" + scopePart + " );" );

        if ( isNotEmpty( dep.getExclusions() ) )
        {
            Iterator it = dep.getExclusions().iterator();
            while ( it.hasNext() )
            {
                Exclusion exclusion = (Exclusion) it.next();
                String exkey = toKey( exclusion );
                out.println( "      addExclusion( dep, \"" + exkey + "\" );" );
            }
        }

        if ( dep.isOptional() )
        {
            out.println( "      dep.setOptional( true );" );
        }

        out.println( "      model." + addMethod + "( dep );" );
    }

    private void writeModelDependencies( Set seenModels, String projectKey, Model model )
    {
        if ( model.getDependencies() == null )
        {
            return;
        }

        Iterator it = model.getDependencies().iterator();

        while ( it.hasNext() )
        {
            Dependency dep = applyDepMan( (Dependency) it.next(), model );

            Model rawModel = getModel( dep );

            try
            {
                writeModel( seenModels, rawModel );
            }
            catch ( InvalidArtifactRTException e )
            {
                getLog().error(
                                "Encountered invalid dependency/artifact during [" + projectKey + "] : "
                                    + e.getMessage(), e );
                throw e;
            }
        }
    }

    private void writeModelDependencyManagement( Set seenModels, String projectKey, Model model )
    {
        if ( model.getDependencyManagement() == null )
        {
            return;
        }

        Iterator it = model.getDependencyManagement().getDependencies().iterator();

        while ( it.hasNext() )
        {
            Dependency dep = (Dependency) it.next();

            Model rawModel = getModel( dep );

            try
            {
                writeModel( seenModels, rawModel );
            }
            catch ( InvalidArtifactRTException e )
            {
                getLog().error(
                                "Encountered invalid dependency/artifact during [" + projectKey + "] : "
                                    + e.getMessage(), e );
                throw e;
            }
        }
    }

    private Dependency applyDepMan( Dependency dependency, Model model )
    {
        if ( model.getDependencyManagement() != null )
        {
            if ( model.getDependencyManagement().getDependencies() != null )
            {
                // Attempt to find matching dep.
                Predicate matchingDep = new MatchingDependencyPredicate( dependency );
                Dependency depman = (Dependency) CollectionUtils.find( model.getDependencyManagement()
                    .getDependencies(), matchingDep );

                if ( depman != null )
                {
                    dependency.setVersion( depman.getVersion() );
                    dependency.setScope( StringUtils.defaultString( depman.getScope(), dependency.getScope() ) );

                    // Found it!
                    return dependency;
                }
            }
        }

        if ( model.getParent() != null )
        {
            Model parentModel = getModel( model.getParent() );
            return applyDepMan( dependency, parentModel );
        }

        return dependency;
    }
}
